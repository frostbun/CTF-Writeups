# RRSSAA

Ở bài này, chúng ta đã được cho [source code](enc.py) và [e, n, c](output.txt)

Xem qua src code thì mình thấy flag được chia làm 2 phần và được encrypt bằng 2 cách khác nhau

## Phần đầu: RSA với N là 1 số nguyên tố mũ 4 lên

```python
p1 = q1 = r1 = s1 = getPrime(512)
n1 = p1 * q1 * r1 * s1
```

Chúng ta đã được cho `n1 = 6490575414546753422169557924726633698938840342804007877593140124713933084247239272632050468659186332284597365791524523203890501075477199471733446503331287392773585633905281136028592442460859381818517915584152977506750156812875265542004792964515179303151752533661952619290383021701963596253894613400006395933540184308383205582620641667831066786941489460633668241024642868786169958309890455670637684750726393954761545971579402229970767454083426068165630397383861060884335031186141866257202083321618111563513626855089058455000733251707282966148763783562830207713984490916122334630807846682310867739481868099531604199361`

Muốn tính được p1 thì ta chỉ cần lấy căn bậc 4 của n1. Nhưng vì n quá lớn nên không thể dùng những hàm có sẵn của python, dùng numpy thì mình thấy hay bị sai số nên mình quyết định tự viết một hàm căn bậc 2 đơn giản bằng tìm kiếm nhị phân:
```python
def sqrt(n):
    l = 1
    r = n
    while l<r:
        m = (l+r)//2
        if m*m == n:
            return m
        if m*m < n:
            l = m+1
        if m*m > n:
            r = m-1
    return l
```

Cuối cùng tính được `p1 = 8975751081836507012481590457678041696015531734268544986023289759883114438487077939811875458134882495997656712678263858001555253906581020870541234001635441`

Và hàm phi Euler sẽ khác với bình thường một chút ([Tham khảo thêm ở đây](https://vi.wikipedia.org/wiki/H%C3%A0m_phi_Euler))
```python
f1 = (p1-1) * p1**3
```

Còn lại ta có thể tính:
```python
d1 = pow(e, -1, f1)
m1 = pow(c1, d1, n1)
```

Ra được nửa đầu của flag: `FPTUHacking{Us3_0f_s1ngl3_pr1m3_4nd`

## Phần đầu: RSA với P và Q là 2 số nguyên tố gần nhau

```python
p2 = getPrime(1024)
q2 = nextprime(p2)
n2 = p2 * q2
```

Vì p và q gần nhau nên sẽ gần căn bậc 2 của n, chúng ta có thể brute force với đoạn code sau:
```python
def close_primes(n):
    for p in range(sqrt(n), n):
        q = n // p
        if p*q == n:
            return p, q
```

Ra được `p2 = 117932741434204302246442682068727983351370447493729150886715353995700352872979006469173038931950091188032286011990002659815031676645339219308073019562105226000622434194945780572464539178280661674912853506047651421699417110064588240735458565888636770353954289429117197937647410702425301735219734617042073061079`
và
`q2 = 117932741434204302246442682068727983351370447493729150886715353995700352872979006469173038931950091188032286011990002659815031676645339219308073019562105226000622434194945780572464539178280661674912853506047651421699417110064588240735458565888636770353954289429117197937647410702425301735219734617042073061007`

Còn lại tính như bình thường:
```python
f2 = (p2-1) * (q2-1)
d2 = pow(e, -1, f2)
m2 = pow(c2, d2, n2)
```

Toàn bộ flag: `FPTUHacking{Us3_0f_s1ngl3_pr1m3_4nd_cl0se_prim3s_w3r3_w4st3_0f_c0mput3r_Cycl35}`

Full src code để giải bài này [ở đây](dec.py)
